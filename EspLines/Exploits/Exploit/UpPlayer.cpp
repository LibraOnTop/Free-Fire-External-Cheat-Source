#include <imgui.h>
#include <imgui_internal.h>
#include <EspLines/Memory/Memory.hpp>
#include <EspLines/Math/Vector/Vector3.hpp>
#include <EspLines/Math/Vector/Vector2.hpp>
#include <EspLines/Aimbot/Aimbot.hpp> 
#include <src/Globals.hpp>
#include <EspLines/Offsets.hpp>
#include <EspLines/Math/WordToScreen.hpp>
#include <iostream>
#include <unordered_map>
#include <thread>
#include <atomic>
#include "UpPlayer.hpp"

std::atomic<bool> upPlayerRunning{ false };
std::thread upPlayerThread;
static std::unordered_map<uintptr_t, Vector3> lockedPositions;

void UpPlayer::UpPlayerr::UpPlayer() {
    if (!g_Globals.Exploits.UpPlayer)
        return;

    if ((GetAsyncKeyState(g_Globals.Exploits.UpPlayerBind) & 0x8000) == 0)
        return;

    if (upPlayerRunning) return;
    upPlayerRunning = true;

    upPlayerThread = std::thread([] {
        while (upPlayerRunning) {
            if ((GetAsyncKeyState(g_Globals.Exploits.UpPlayerBind) & 0x8000) == 0) {
                std::this_thread::sleep_for(std::chrono::milliseconds(1));
                continue;
            }

            if (g_Globals.EspConfig.Width == -1 || g_Globals.EspConfig.Height == -1 || !g_Globals.EspConfig.Matrix) {
                std::this_thread::sleep_for(std::chrono::milliseconds(1));
                continue;
            }

            uint32_t localPlayer = g_Globals.EspConfig.LocalPlayer;
            if (!localPlayer) return;

            Player target;
            float bestDist = FLT_MAX;
            Vector2 screenCenter(g_Globals.EspConfig.Width / 2, g_Globals.EspConfig.Height / 2);

            for (const auto& pair : g_Globals.EspConfig.Entities) {
                const Player& entity = pair.second;
                if (!entity.IsKnown || entity.IsDead || entity.IsKnocked) continue;

                Vector2 screenPos = W2S::WorldToScreen(
                    g_Globals.EspConfig.ViewMatrix,
                    entity.Head,
                    g_Globals.EspConfig.Width,
                    g_Globals.EspConfig.Height
                );

                if (screenPos.X < 1 || screenPos.Y < 1) continue;

                float dist = Vector2::Distance(screenCenter, screenPos);
                if (dist < bestDist) {
                    bestDist = dist;
                    target = entity;
                }
            }

            if (!target.Address) {
                std::this_thread::sleep_for(std::chrono::milliseconds(10));
                continue;
            }

            uint32_t bone1, bone2, bone3, bone4;
            if (!Mem.ReadFast2<uint32_t>(target.Address + Offsets::Bones::Root, &bone1)) continue;
            if (!Mem.ReadFast2<uint32_t>(bone1 + 0x8, &bone2)) continue;
            if (!Mem.ReadFast2<uint32_t>(bone2 + 0x8, &bone3)) continue;
            if (!Mem.ReadFast2<uint32_t>(bone3 + 0x20, &bone4)) continue;

            Vector3 pos;
            if (!Mem.ReadFast2<Vector3>(bone4 + 0x80, &pos)) continue;

            if (lockedPositions.find(target.Address) == lockedPositions.end()) {
                Vector3 lockedPos = pos;
                lockedPos.Y += 2.5f;
                lockedPositions[target.Address] = lockedPos;
            }

            Mem.Write<Vector3>(bone4 + 0x80, lockedPositions[target.Address]);
            std::this_thread::sleep_for(std::chrono::milliseconds(1));
        }
        });

    upPlayerThread.detach();
}

void UpPlayer::UpPlayerr::StopUpPlayer() {
    upPlayerRunning = false;
    if (upPlayerThread.joinable()) {
        upPlayerThread.join();
    }
    lockedPositions.clear();
}
