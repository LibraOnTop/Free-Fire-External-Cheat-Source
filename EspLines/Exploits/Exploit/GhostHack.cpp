#include <imgui.h>
#include <imgui_internal.h>
#include <EspLines/Memory/Memory.hpp>
#include <EspLines/Math/Vector/Vector3.hpp>
#include <EspLines/Math/Vector/Vector2.hpp>
#include <EspLines/Math/WordToScreen.hpp>
#include <src/Globals.hpp>
#include <EspLines/Offsets.hpp>
#include <unordered_map>
#include <iostream>
#include <atomic>
#include <thread>
#include <optional>
#include "GhostHack.hpp"

std::atomic<bool> ghostHackRunning{ false };
std::thread ghostHackThread;
static std::optional<Vector3> originalPosition = std::nullopt;
static bool lastKeyState = false;
static bool isToggled = false;

bool GhostHack::GhostHack::IsActive() {
    return ghostHackRunning && isToggled && originalPosition.has_value();
}

std::optional<Vector3> GhostHack::GhostHack::GetGhostBodyPosition() {
    return originalPosition;
}

void GhostHack::GhostHack::Start() {
    if (ghostHackRunning) return;
    ghostHackRunning = true;

    ghostHackThread = std::thread([] {
        while (ghostHackRunning) {
            try {
                bool currentKeyState = (GetAsyncKeyState(VK_F9) & 0x8000) != 0;
                if (currentKeyState && !lastKeyState) {
                    isToggled = !isToggled;
                    if (!isToggled && originalPosition.has_value()) {
                        Mem.Write<Vector3>(g_Globals.EspConfig.LocalPlayer + Offsets::GhostMode, originalPosition.value());
                        originalPosition = std::nullopt;
                    }
                }
                lastKeyState = currentKeyState;
                
                if (isToggled) {
                    // Ghost hack logic here
                    if (!originalPosition.has_value()) {
                        Vector3 currentPos = Mem.Read<Vector3>(g_Globals.EspConfig.LocalPlayer + Offsets::GhostMode);
                        originalPosition = currentPos;
                    }
                }
                else if (originalPosition.has_value()) {
                    Mem.Write<Vector3>(g_Globals.EspConfig.LocalPlayer + Offsets::GhostMode, originalPosition.value());
                    originalPosition = std::nullopt;
                }

                std::this_thread::sleep_for(std::chrono::milliseconds(10));
            }
            catch (const std::exception& e) {
                std::cerr << "GhostHack exception: " << e.what() << std::endl;
                std::this_thread::sleep_for(std::chrono::milliseconds(50));
            }
        }
    });
    
    if (ghostHackThread.joinable()) {
        ghostHackThread.detach();
    }
}

void GhostHack::GhostHack::Stop() {
    ghostHackRunning = false;
    if (ghostHackThread.joinable()) {
        ghostHackThread.join();
    }
    
    if (originalPosition.has_value()) {
        Mem.Write<Vector3>(g_Globals.EspConfig.LocalPlayer + Offsets::GhostMode, originalPosition.value());
        originalPosition = std::nullopt;
    }
}
