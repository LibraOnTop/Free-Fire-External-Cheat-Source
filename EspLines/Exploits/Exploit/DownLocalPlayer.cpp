#include <imgui.h>
#include <imgui_internal.h>
#include <EspLines/Memory/Memory.hpp>
#include <EspLines/Math/Vector/Vector3.hpp>
#include <EspLines/Math/Vector/Vector2.hpp>
#include <EspLines/Aimbot/Aimbot.hpp>
#include <src/Globals.hpp>
#include <EspLines/Offsets.hpp>
#include <EspLines/Math/WordToScreen.hpp>
#include <iostream>
#include <atomic>
#include <thread>
#include "DownLocalPlayer.hpp"

std::atomic<bool> downLocalRunning{ false };
std::thread downLocalThread;
static bool lastKeyStateLocal = false;
static bool isToggled = false;
constexpr float LocalDownOffset = 2.0f;

void DownLocalPlayer::DownLocalPlayerr::DownLocal() {
    if (downLocalRunning) return;
    downLocalRunning = true;

    downLocalThread = std::thread([] {
        while (downLocalRunning) {
            if (!g_Globals.Exploits.DownLocalPlayer) {
                std::this_thread::sleep_for(std::chrono::milliseconds(10));
                continue;
            }

            bool currentKeyState = (GetAsyncKeyState(g_Globals.Exploits.DownLocalPlayerBind) & 0x8000) != 0;

            if (currentKeyState && !lastKeyStateLocal) {
                isToggled = !isToggled; 
            }
            lastKeyStateLocal = currentKeyState;

            if (!isToggled) {
                std::this_thread::sleep_for(std::chrono::milliseconds(10));
                continue;
            }

            if (!g_Globals.EspConfig.Matrix || g_Globals.EspConfig.Width == -1 || g_Globals.EspConfig.Height == -1) {
                std::this_thread::sleep_for(std::chrono::milliseconds(10));
                continue;
            }

            uint32_t localPlayer = g_Globals.EspConfig.LocalPlayer;
            if (!localPlayer) {
                std::this_thread::sleep_for(std::chrono::milliseconds(10));
                continue;
            }

            uint32_t rootBone, transform1, transform2, matrix;
            Vector3 currentPos;

            if (!Mem.ReadFast2<uint32_t>(localPlayer + Offsets::Bones::Root, &rootBone)) {
                std::this_thread::sleep_for(std::chrono::milliseconds(10));
                continue;
            }
            if (!Mem.ReadFast2<uint32_t>(rootBone + 0x8, &transform1)) {
                std::this_thread::sleep_for(std::chrono::milliseconds(10));
                continue;
            }
            if (!Mem.ReadFast2<uint32_t>(transform1 + 0x8, &transform2)) {
                std::this_thread::sleep_for(std::chrono::milliseconds(10));
                continue;
            }
            if (!Mem.ReadFast2<uint32_t>(transform2 + 0x20, &matrix)) {
                std::this_thread::sleep_for(std::chrono::milliseconds(10));
                continue;
            }
            if (!Mem.ReadFast2<Vector3>(matrix + 0x80, &currentPos)) {
                std::this_thread::sleep_for(std::chrono::milliseconds(10));
                continue;
            }

            Vector3 newPos = currentPos;
            newPos.Y -= LocalDownOffset;

            try {
                Mem.Write<Vector3>(matrix + 0x80, newPos);
            }
            catch (const std::exception& e) {
                std::cerr << "Exception while writing position: " << e.what() << std::endl;
            }

            std::this_thread::sleep_for(std::chrono::milliseconds(10));
        }
        });
    downLocalThread.detach();
}

void DownLocalPlayer::DownLocalPlayerr::StopDownLocal() {
    downLocalRunning = false;
    isToggled = false; 
    if (downLocalThread.joinable()) {
        downLocalThread.join();
    }
}

bool DownLocalPlayer::DownLocalPlayerr::IsActive() {
    return downLocalRunning && isToggled;
}