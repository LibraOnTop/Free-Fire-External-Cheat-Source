#include <imgui.h>
#include <imgui_internal.h>
#include <EspLines/Memory/Memory.hpp>
#include <EspLines/Math/Vector/Vector3.hpp>
#include <EspLines/Math/Vector/Vector2.hpp>
#include <EspLines/Aimbot/Aimbot.hpp> 
#include <src/Globals.hpp>
#include <EspLines/Offsets.hpp>
#include <EspLines/Math/WordToScreen.hpp>
#include <iostream>
#include <unordered_map>
#include <thread>
#include <atomic>
#include "Telepneu.hpp"

std::atomic<bool> telepneuRunning{ false };
std::thread telepneuThread;

void Telepneu::Telepneuu::TelepneuWork() {
    if (telepneuRunning) return;
    telepneuRunning = true;

    telepneuThread = std::thread([] {
        while (true) {
            if (!telepneuRunning) {
                break;
            }

            if (!g_Globals.Exploits.Telepneu) {
                std::this_thread::sleep_for(std::chrono::milliseconds(10));
                continue;
            }

            for (const auto& pair : g_Globals.EspConfig.Entities) {
                const Player& entity = pair.second;
                if (!entity.IsKnown || entity.IsDead || (g_Globals.AimBot.IgnoreKnocked && entity.IsKnocked))
                    continue;

                uint32_t enemyRootBone;
                if (!Mem.ReadFast2<uint32_t>(entity.Address + Offsets::Bones::Root, &enemyRootBone))
                    continue;

                uint32_t bone1, bone2, bone3, bone4;
                Vector3 pospneu;

                if (!Mem.ReadFast2<uint32_t>(enemyRootBone + 0x8, &bone1)) continue;
                if (!Mem.ReadFast2<uint32_t>(bone1 + 0x8, &bone2)) continue;
                if (!Mem.ReadFast2<uint32_t>(bone2 + 0x20, &bone3)) continue;
                if (!Mem.ReadFast2<Vector3>(bone3 + 0x80, &pospneu)) continue;

                uint32_t localPlayer = g_Globals.EspConfig.LocalPlayer;
                if (localPlayer != 0) {
                    Mem.Write<Vector3>(localPlayer + Offsets::telepneu, pospneu);
                }
            }

            std::this_thread::sleep_for(std::chrono::milliseconds(10));
        }
        });

    telepneuThread.detach();
}

void Telepneu::Telepneuu::StopTelepneu() {
    telepneuRunning = false;
    if (telepneuThread.joinable()) {
        telepneuThread.join();
    }
}