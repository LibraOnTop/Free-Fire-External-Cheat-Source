#include <imgui.h>
#include <imgui_internal.h>
#include <EspLines/Memory/Memory.hpp>
#include <EspLines/Math/Vector/Vector3.hpp>
#include <EspLines/Math/Vector/Vector2.hpp>
#include <EspLines/Aimbot/Aimbot.hpp>
#include <src/Globals.hpp>
#include <EspLines/Offsets.hpp>
#include <EspLines/Math/WordToScreen.hpp>
#include <iostream>
#include <algorithm>
#include <unordered_map>
#include <thread>
#include <atomic>
#include <chrono>
#include "DownPlayer.hpp"

#define NOMINMAX 

std::atomic<bool> downPlayerRunning{ false };
std::thread downPlayerThread;
constexpr float DownOffset = 0.45f;
static std::unordered_map<uint32_t, Vector3> originalPositions;
static uint32_t currentTarget = 0;
static uint32_t lastTarget = 0;

bool DownPlayer::DownPlayerr::IsLocalFiring() {
    bool firing = false;
    if (!Mem.ReadFast2<bool>(g_Globals.EspConfig.LocalPlayer + Offsets::tiro, &firing))
        return false;
    return firing;
}

uint32_t FindClosestTarget() {
    uint32_t bestTarget = 0;
    float closestDist = FLT_MAX;
    Vector2 screenCenter = {
        g_Globals.EspConfig.Width / 2.0f,
        g_Globals.EspConfig.Height / 2.0f
    };

    for (const auto& pair : g_Globals.EspConfig.Entities) {
        const Player& entity = pair.second;
        if (!entity.IsKnown || entity.IsDead || entity.IsKnocked) continue;

        Vector2 screenPos = W2S::WorldToScreen(
            g_Globals.EspConfig.ViewMatrix,
            entity.Head,
            g_Globals.EspConfig.Width,
            g_Globals.EspConfig.Height
        );

        if (screenPos.X < 1 || screenPos.Y < 1 || screenPos.X > g_Globals.EspConfig.Width || screenPos.Y > g_Globals.EspConfig.Height) continue;

        float crosshairDist = Vector2::Distance(screenCenter, screenPos);
        if (crosshairDist > g_Globals.AimBot.Fov) continue;

        if (crosshairDist < closestDist) {
            closestDist = crosshairDist;
            bestTarget = entity.Address;
        }
    }
    return bestTarget;
}

void ApplyDown(uint32_t entityAddr) {
    uint32_t bone1 = 0, bone2 = 0, bone3 = 0, bone4 = 0;
    Vector3 currentPos;

    if (!Mem.ReadFast2<uint32_t>(entityAddr + Offsets::Bones::Root, &bone1) || !bone1) return;
    if (!Mem.ReadFast2<uint32_t>(bone1 + 0x8, &bone2) || !bone2) return;
    if (!Mem.ReadFast2<uint32_t>(bone2 + 0x8, &bone3) || !bone3) return;
    if (!Mem.ReadFast2<uint32_t>(bone3 + 0x20, &bone4) || !bone4) return;
    if (!Mem.ReadFast2<Vector3>(bone4 + 0x80, &currentPos)) return;

    if (originalPositions.find(entityAddr) == originalPositions.end()) {
        originalPositions[entityAddr] = currentPos;
    }

    float targetY = originalPositions[entityAddr].Y - DownOffset;
    if (currentPos.Y != targetY) {
        Vector3 newPos = currentPos;
        newPos.Y = targetY;
        try {
            Mem.Write<Vector3>(bone4 + 0x80, newPos);
        }
        catch (const std::exception& e) {
            std::cerr << "Write failed: " << e.what() << std::endl;
        }
    }
}

void DownPlayer::DownPlayerr::RestoreAllPositions() {
    for (auto it = originalPositions.begin(); it != originalPositions.end(); ) {
        uint32_t entityAddr = it->first;
        uint32_t bone1 = 0, bone2 = 0, bone3 = 0, bone4 = 0;
        Vector3 currentPos;

        if (!Mem.ReadFast2<uint32_t>(entityAddr + Offsets::Bones::Root, &bone1) || !bone1) {
            it = originalPositions.erase(it);
            continue;
        }
        if (!Mem.ReadFast2<uint32_t>(bone1 + 0x8, &bone2) || !bone2) {
            it = originalPositions.erase(it);
            continue;
        }
        if (!Mem.ReadFast2<uint32_t>(bone2 + 0x8, &bone3) || !bone3) {
            it = originalPositions.erase(it);
            continue;
        }
        if (!Mem.ReadFast2<uint32_t>(bone3 + 0x20, &bone4) || !bone4) {
            it = originalPositions.erase(it);
            continue;
        }
        if (!Mem.ReadFast2<Vector3>(bone4 + 0x80, &currentPos)) {
            it = originalPositions.erase(it);
            continue;
        }

        if (currentPos.Y != it->second.Y) {
            Vector3 restoredPos = currentPos;
            restoredPos.Y = it->second.Y;
            try {
                Mem.Write<Vector3>(bone4 + 0x80, restoredPos);
            }
            catch (const std::exception& e) {
                std::cerr << "Restore failed: " << e.what() << std::endl;
            }
        }
        ++it;
    }
    originalPositions.clear();
}

void DownPlayer::DownPlayerr::DownPlayer() {
    if (downPlayerRunning) return;
    downPlayerRunning = true;

    downPlayerThread = std::thread([] {
        while (downPlayerRunning) {
            if (!g_Globals.Exploits.DownPlayer) {
                std::this_thread::sleep_for(std::chrono::milliseconds(10));
                continue;
            }

            bool keyPressed = (GetAsyncKeyState(g_Globals.Exploits.DownPlayerBind) & 0x8000) != 0;
            if (!keyPressed) {
                RestoreAllPositions();
                currentTarget = 0;
                lastTarget = 0;
                std::this_thread::sleep_for(std::chrono::milliseconds(10));
                continue;
            }

            if (g_Globals.EspConfig.Width == -1 || g_Globals.EspConfig.Height == -1 || !g_Globals.EspConfig.Matrix) {
                std::this_thread::sleep_for(std::chrono::milliseconds(10));
                continue;
            }

            uint32_t localPlayer = g_Globals.EspConfig.LocalPlayer;
            if (!localPlayer) {
                std::this_thread::sleep_for(std::chrono::milliseconds(10));
                continue;
            }

            bool firing = IsLocalFiring();
            if (firing) {
                currentTarget = FindClosestTarget();
                if (currentTarget) {
                    if (currentTarget != lastTarget) {
                        lastTarget = currentTarget;
                    }
                    ApplyDown(currentTarget);
                }
                else {
                    RestoreAllPositions();
                }
            }
            else {
                RestoreAllPositions();
                currentTarget = 0;
                lastTarget = 0;
            }

            std::this_thread::sleep_for(std::chrono::milliseconds(6));
        }

        RestoreAllPositions();
        });

    downPlayerThread.detach();
}

void DownPlayer::DownPlayerr::StopDownPlayer() {
    downPlayerRunning = false;
    if (downPlayerThread.joinable()) {
        downPlayerThread.join();
    }
    RestoreAllPositions();
}