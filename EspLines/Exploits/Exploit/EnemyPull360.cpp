#include <imgui.h>
#include <imgui_internal.h>
#include <EspLines/Memory/Memory.hpp>
#include <EspLines/Math/Vector/Vector3.hpp>
#include <EspLines/Math/Vector/Vector2.hpp>
#include <EspLines/Math/WordToScreen.hpp>
#include <src/Globals.hpp>
#include <EspLines/Offsets.hpp>
#include <unordered_map>
#include <thread>
#include <atomic>
#include <chrono>
#include <iostream>
#include <algorithm>
#include "EnemyPull360.hpp"
#ifdef min
#undef min
#endif

std::atomic<bool> enemyPullRunning{ false };
std::thread enemyPullThread;

static std::unordered_map<uint32_t, Vector3> originalPositions;
static uint32_t currentTargetId = 0;
static bool wasFiringLastFrame = false;
static bool isTargetPositionLocked = false;
static Vector3 lockedTargetPosition;

bool EnemyPull::EnemyPull360::IsLocalFiring() {
    bool firing = false;
    if (!Mem.ReadFast2<bool>(g_Globals.EspConfig.LocalPlayer + Offsets::tiro, &firing))
        return false;
    return firing;
}

uint32_t FindClosestEntity() {
    if (g_Globals.EspConfig.Width == -1 || g_Globals.EspConfig.Height == -1 ||
        !g_Globals.EspConfig.Matrix || g_Globals.EspConfig.Entities.empty()) {
        return 0;
    }

    float centerX = g_Globals.EspConfig.Width / 2.0f;
    float centerY = g_Globals.EspConfig.Height / 2.0f;
    float fov = 450.0f;

    uint32_t closestEntity = 0;
    float closestDistanceSqr = FLT_MAX;

    for (const auto& pair : g_Globals.EspConfig.Entities) {
        const Player& entity = pair.second;

        if (entity.IsDead || entity.IsKnocked || !entity.IsKnown)
            continue;

        Vector2 head2D = W2S::WorldToScreen(
            g_Globals.EspConfig.ViewMatrix,
            entity.Head,
            g_Globals.EspConfig.Width,
            g_Globals.EspConfig.Height
        );

        if (head2D.X < 1 || head2D.Y < 1)
            continue;

        float dx = head2D.X - centerX;
        float dy = head2D.Y - centerY;
        float distanceSqr = dx * dx + dy * dy;

        if (distanceSqr <= fov * fov && distanceSqr < closestDistanceSqr) {
            closestEntity = entity.Address;
            closestDistanceSqr = distanceSqr;
        }
    }

    return closestEntity;
}

void LockTargetPosition(uint32_t entityAddr) {
    currentTargetId = entityAddr;

    uint32_t rootBone, transformValue, transformObj, matrixPtr;
    Vector3 posA_Enemy;

    if (!Mem.ReadFast2<uint32_t>(entityAddr + Offsets::Bones::Root, &rootBone) || rootBone == 0) return;
    if (!Mem.ReadFast2<uint32_t>(rootBone + 0x8, &transformValue) || transformValue == 0) return;
    if (!Mem.ReadFast2<uint32_t>(transformValue + 0x8, &transformObj) || transformObj == 0) return;
    if (!Mem.ReadFast2<uint32_t>(transformObj + 0x20, &matrixPtr) || matrixPtr == 0) return;
    if (!Mem.ReadFast2<Vector3>(matrixPtr + 0x80, &posA_Enemy)) return;

    if (originalPositions.find(entityAddr) == originalPositions.end()) {
        originalPositions[entityAddr] = posA_Enemy;
    }

    Vector3 posB_PlayerCamera = g_Globals.EspConfig.MainCamera;
    Vector3 vecC_ViewDirection = {g_Globals.EspConfig.ViewMatrix.m02, g_Globals.EspConfig.ViewMatrix.m12, g_Globals.EspConfig.ViewMatrix.m22};
    vecC_ViewDirection = Vector3::Normalized(vecC_ViewDirection);
    float realDistance3D = Vector3::Distance(posB_PlayerCamera, posA_Enemy);

    lockedTargetPosition = posB_PlayerCamera + (vecC_ViewDirection * realDistance3D);
    lockedTargetPosition.Y += g_Globals.Exploits.PullHeightOffset;
    isTargetPositionLocked = true;
}

void ForceEntityToLockedPosition() {
    if (currentTargetId == 0 || g_Globals.EspConfig.Entities.find(currentTargetId) == g_Globals.EspConfig.Entities.end()) {
        EnemyPull::EnemyPull360::RestoreOriginalPosition();
        return;
    }

    uint32_t rootBone, transformValue, transformObj, matrixPtr;

    if (!Mem.ReadFast2<uint32_t>(currentTargetId + Offsets::Bones::Root, &rootBone) || rootBone == 0) return;
    if (!Mem.ReadFast2<uint32_t>(rootBone + 0x8, &transformValue) || transformValue == 0) return;
    if (!Mem.ReadFast2<uint32_t>(transformValue + 0x8, &transformObj) || transformObj == 0) return;
    if (!Mem.ReadFast2<uint32_t>(transformObj + 0x20, &matrixPtr) || matrixPtr == 0) return;

    Mem.Write<Vector3>(matrixPtr + 0x80, lockedTargetPosition);
}

void EnemyPull::EnemyPull360::RestoreOriginalPosition() {
    if (isTargetPositionLocked && currentTargetId != 0) {
        auto it = originalPositions.find(currentTargetId);
        if (it != originalPositions.end()) {
            uint32_t rootBone, transformValue, transformObj, matrixPtr;

            if (Mem.ReadFast2<uint32_t>(currentTargetId + Offsets::Bones::Root, &rootBone) && rootBone != 0 &&
                Mem.ReadFast2<uint32_t>(rootBone + 0x8, &transformValue) && transformValue != 0 &&
                Mem.ReadFast2<uint32_t>(transformValue + 0x8, &transformObj) && transformObj != 0 &&
                Mem.ReadFast2<uint32_t>(transformObj + 0x20, &matrixPtr) && matrixPtr != 0) {

                Mem.Write<Vector3>(matrixPtr + 0x80, it->second);
            }

            originalPositions.erase(currentTargetId);
        }
    }

    currentTargetId = 0;
    isTargetPositionLocked = false;
}

void EnemyPull::EnemyPull360::Start() {
    if (enemyPullRunning) return;
    enemyPullRunning = true;

    enemyPullThread = std::thread([] {
        while (enemyPullRunning) {
            if (!g_Globals.Exploits.EnemyPullEnabled) {
                RestoreOriginalPosition();
                std::this_thread::sleep_for(std::chrono::milliseconds(100));
                continue;
            }

            bool isCurrentlyFiring = IsLocalFiring();

            if (isCurrentlyFiring) {
                if (!isTargetPositionLocked) {
                    uint32_t closestEntity = FindClosestEntity();
                    if (closestEntity != 0) {
                        LockTargetPosition(closestEntity);
                    }
                }

                if (isTargetPositionLocked) {
                    ForceEntityToLockedPosition();
                }

                wasFiringLastFrame = true;
            }
            else if (wasFiringLastFrame) {
                RestoreOriginalPosition();
                wasFiringLastFrame = false;
            }

            std::this_thread::sleep_for(std::chrono::milliseconds(1));
        }

        RestoreOriginalPosition();
        });

    enemyPullThread.detach();
}

void EnemyPull::EnemyPull360::Stop() {
    enemyPullRunning = false;
    if (enemyPullThread.joinable()) {
        enemyPullThread.join();
    }
    RestoreOriginalPosition();
}